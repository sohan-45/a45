# ass 1

import sys

visited = []
queue = []

def bfs(visited, graph, node,searchNodee):
  print("BFS: ",end='')
  visited.append(node)
  queue.append(node)

  while queue:
    m = queue.pop(0)
    print (m, end = " ")
    #v
    if(m == searchNodee):
        break
    

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

dfsVisited = set()

def dfs(dfsVisited, graph, node, searchNodee):  
    if node not in dfsVisited:
        #1
        print (node, end=' ')
        if(node == searchNodee):
           #a
           sys.exit()
        dfsVisited.add(node)
        for neighbour in graph[node]:
            dfs(dfsVisited, graph, neighbour, searchNodee) #c

graph = {}

while True:
    root = input("Enter the root node: [input/done]  ")

    if(root=="done"):
        break
        
    if root not in graph:
        graph[root] = []

        while True:
            #k
            child = input("Please enter the child nodes of "+root+": [Enter input/done]  ")

            if child == "done":
                print()
                break

            if child not in graph[root]:
                graph[root].append(child)
    
print("\nThe graph is:\n")
print(graph, end='\n\n')

searchNode = input("Enter the node you want to search: ",)
print()
first_key = next(iter(graph))
bfs(visited, graph, first_key, searchNode)
print()
print("DFS: ",end='')
dfs(dfsVisited, graph, first_key, searchNode)

# enter the input in following way:
# a
# b
# c
# done
# b
# d
# e
# done
# c
# f
# g 
# done
# d
# done
# e
# done
# f
# done
# g
# done
# done
# c


# ass 1 done

# ass 2 tic tac toe

import numpy as np

class Node:
    def __init__(self, state, parent=None):
        self.state = state
        self.parent = parent
        self.g_score = 0 if parent is None else parent.g_score + 1      #r
        self.h_score = self.heuristic()
    
    def f_score(self):
        return self.g_score + self.h_score
    
    def path(self):
        path = [self.state]
        node = self.parent
        while node is not None:
            path.append(node.state)
            node = node.parent
        return path[::-1]
    
    def heuristic(self):
        winner = check_winner(self.state)           
        if winner is not None:
            #3
            if winner == 1:
                return 100 - self.g_score
            else:
                return -100 + self.g_score
        else:
            return self.get_empty_spaces() - self.get_opponent_empty_spaces()
        
    def get_empty_spaces(self):
        return np.sum(self.state == -1)
    
    def get_opponent_empty_spaces(self):
        return np.sum(self.state == 1)          #x
    
    def __eq__(self, other):
        return np.array_equal(self.state, other.state)
    
    def __hash__(self):
        return hash(self.state.tostring())

def check_winner(state):
    # Check rows
    for i in range(3):
        #o
        if np.all(state[i, :] == 1):
            return 1
        elif np.all(state[i, :] == 0):
            return 0
    
    # Check columns
    for i in range(3):
        if np.all(state[:, i] == 1):
            return 1
        elif np.all(state[:, i] == 0):
            return 0
    
    # Check diagonals
    if np.all(np.diag(state) == 1) or np.all(np.diag(np.fliplr(state)) == 1):
        return 1
    elif np.all(np.diag(state) == 0) or np.all(np.diag(np.fliplr(state)) == 0):
        return 0
    
    # Check for tie
    if np.sum(state == -1) == 0:
        return -1   
    
    # No winner yet     #r
    return None

def get_possible_moves(state, player):
    moves = []
    for i in range(3):
        for j in range(3):
            if state[i, j] == -1:
                new_state = state.copy()
                new_state[i, j] = player
                moves.append(new_state)
    return moves

def a_star(start_state, player):
    open_list = [Node(start_state)]
    closed_list = []

    while open_list:
        current = min(open_list, key=lambda x: x.f_score())
        open_list.remove(current)
        closed_list.append(current)

        if check_winner(current.state) is not None:
            # If the current state is a win for the AI player, return the path
            return current.path()

        for child_state in get_possible_moves(current.state, player):
            child = Node(child_state, current)
            if child in closed_list:
                continue
            if child not in open_list:
                open_list.append(child)
            else:
                # Update the existing node if this path is better
                existing_child = open_list[open_list.index(child)]
                if child.g_score < existing_child.g_score:
                    existing_child.parent = current

    # If no path is found, return None
    return None

def print_board(state):
    """
    Prints the Tic Tac Toe board in a human-readable format.
    """
    symbols = {-1: " ", 0: "O", 1: "X"}  # Map player numbers to symbols
    for i in range(3):
        print("-------------")
        row = "|"
        for j in range(3):
            row += " " + symbols[state[i, j]] + " |"
        print(row)
    print("-------------")


def main():
    # Initialize the game board
    board = np.full((3, 3), -1)
    print_board(board)

    # Game loop
    while True:
        # Player 1 (human) turn
        print("Player 1 (X) turn.")
        row = int(input("Enter row number (0-2): "))
        col = int(input("Enter column number (0-2): "))
        if board[row, col] != -1:
            print("Invalid move. Try again.")
            continue
        board[row, col] = 1
        print_board(board)
        winner = check_winner(board)
        if winner is not None:
            break

        # AI player (player 2) turn
        print("Player 2 (O) turn.")
        path = a_star(board, 0)
        if path is None:
            print("Error: AI failed to find a valid move.")
            continue
        board = path[1]
        print_board(board)
        winner = check_winner(board)
        if winner is not None:
            break

    # Print the result
    if winner == 1:
        print("Player 1 (X) wins!")
    elif winner == 0:
        print("Player 2 (O) wins!")
    else:
        print("It's a tie!")

if __name__ == "__main__":
    main()


# ass 2 done

# ass 3

import sys

class Graph:
    def __init__(self, vertices):           #v
        self.vertices = vertices
        self.graph = [[0 for column in range(vertices)]
                      for row in range(vertices)]

    def printMST(self, parent):
        print("Edge \tWeight")#1
        for i in range(1, self.vertices):
            print(parent[i], "-", i, "\t", self.graph[i][parent[i]])

    
    def minKey(self, key, mstSet):
        min = sys.maxsize
        for v in range(self.vertices):
            if key[v] < min and mstSet[v] == False:
                min = key[v]
                min_index = v
        return min_index    #a

    def primMST(self):
        key = [sys.maxsize] * self.vertices
        parent = [None] * self.vertices
        key[0] = 0
        mstSet = [False] * self.vertices
        parent[0] = -1

        for cout in range(self.vertices):
            u = self.minKey(key, mstSet)
            mstSet[u] = True

            for v in range(self.vertices):  #c
                if self.graph[u][v] > 0 and mstSet[v] == False and key[v] > self.graph[u][v]:
                    key[v] = self.graph[u][v]
                    parent[v] = u   

        self.printMST(parent)


#k
num_vertices = int(input("Enter the number of vertices in the graph: "))

graph = Graph(num_vertices)

for i in range(num_vertices):
    for j in range(num_vertices):
        if i != j and graph.graph[i][j] == 0:
            weight = int(input(f"Enter the weight of edge ({i}, {j}): "))
            graph.graph[i][j] = weight
            graph.graph[j][i] = weight

graph.primMST()


# ass 3 done


# ass 4 

# branch and bound

def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(board[i][j], end = " ")
        print()
 

def isSafe(row, col, nd, rd,rowLookup, ndLookup,rdLookup):
    if (ndLookup[nd[row][col]] or rdLookup[rd[row][col]] or rowLookup[row]):
        return False
    return True
 

def solveNQueensUtil(board, col, nd, rd,rowLookup, ndLookup,rdLookup):   
    if(col >= N):
        return True
    for i in range(N):
        if(isSafe(i, col, nd, rd,rowLookup, ndLookup,rdLookup)):
                     
           
            board[i][col] = 1
            rowLookup[i] = True
            ndLookup[nd[i][col]] = True
            rdLookup[rd[i][col]] = True
             
           
            if(solveNQueensUtil(board, col + 1,nd, rd,rowLookup, ndLookup,rdLookup)):
                return True            
            board[i][col] = 0
            rowLookup[i] = False
            ndLookup[nd[i][col]] = False
            rdLookup[rd[i][col]] = False    
    return False
 
def solveNQueens(N):
    
    board = [[0 for i in range(N)] for j in range(N)]
     
    
    nd = [[0 for i in range(N)] for j in range(N)]
    rd = [[0 for i in range(N)] for j in range(N)]    
    rowLookup = [False] * N
     
    
    x = 2 * N - 1
    ndLookup = [False] * x
    rdLookup= [False] * x
     

    for r in range(N):
        for c in range(N):
            nd[r][c] = r + c
            rd[r][c] = r - c + N - 1
     
    if(solveNQueensUtil(board, 0, nd, rd,rowLookup, ndLookup,rdLookup) == False):
        print("Solution does not exist")
        return False
         
    
    printSolution(board)
    return True
 

N=int(input("Enter a Number: "))
solveNQueens(N)


# backtracking

from typing import List
boardcount=0
def isboardok(chessboard:List,row:int,col:int):
    for c in range(col):
        if(chessboard[row][c]=='Q'):
            return False
    for r,c in zip(range(row-1,-1,-1),range(col-1,-1,-1)):
        if(chessboard[r][c]=='Q'):
            return False
    for r,c in zip(range(row+1,len(chessboard),1),range(col-1,-1,-1)):
        if(chessboard[r][c]=='Q'):
            return False
    return True
 
 
def displayboard(chessboard:List):
    for row in chessboard:
        print(row)
    print()
 
 
def placenqueens(chessboard:List,col:int):
    global boardcount
    if(col>=len(chessboard)):
        boardcount+=1
        print("Board"+str(boardcount))
        print("======================")
        displayboard(chessboard)
        print("======================\n\n")
    else:
        for row in range(len(chessboard)):
            chessboard[row][col]='Q'
            if(isboardok(chessboard,row,col)==True):
                placenqueens(chessboard,col+1)
            chessboard[row][col]='.' 

chessboard=[]
N=int(input("Enter chessboard size: "))
for i in range(N):
    row=["."]*N
    chessboard.append(row)
 
placenqueens(chessboard,0)

# ass 4 done


# ass 5

pip install chatterbot

pip install chatterbot_corpus

import spacy

from spacy.cli.download import download
download(model="en_core_web_sm")

from chatterbot import ChatBot

from chatterbot.trainers import ListTrainer

from chatterbot import ChatBot

from chatterbot.trainers import ListTrainer

chatbot = ChatBot('name')

trainer = ListTrainer(chatbot)

trainer.train([
	"Hi, can I help you?",
	"Sure, I'd like to book a flight to Iceland.",
	"Your flight has been booked."
])

response = chatbot.get_response('I would like to book a flight.')

print(response)

while True:
	query= input()
	if query == 'exit':
		break
	ans=chatbot.get_response(query)
	print("Bot:",ans)

# ass 5 done

# ass 6 expert system

go:-
hypothesis(Disease),
write('It is suggested that the patient has '),
write(Disease),
nl,
undo;
write('Sorry, the system is unable to identify the disease'),nl,undo.


hypothesis(cold) :-
symptom(headache),
symptom(runny_nose),
symptom(sneezing),
symptom(sore_throat),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Tylenol'),
nl,
write('2: Panadol'),
nl,
write('3: Nasal spray'),
nl,
write('Please weare warm cloths because'),
nl,!.


hypothesis(influenza) :-
symptom(sore_throat),
symptom(fever),
symptom(headache),
symptom(chills),
symptom(body_ache),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Tamiflu'),
nl,
write('2: Panadol'),
nl,
write('3: Zanamivir'),
nl,
write('Please take a warm bath and do salt gargling because'),
nl,!.


hypothesis(typhoid) :-
symptom(headache),
symptom(abdominal_pain),
symptom(poor_appetite),
symptom(fever),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Chloramphenicol'),
nl,
write('2: Amoxicillin'),
nl,
write('3: Ciprofloxacin'),
nl,
write('4: Azithromycin'),
nl,
write('Please do complete bed rest and take soft diet because'),
nl,!.


hypothesis(chicken_pox) :-
symptom(rash),
symptom(body_ache),
symptom(fever),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Varicella vaccine'),
nl,
write('2: Immunoglobulin'),
nl,
write('3: Acetomenaphin'),
nl,
write('4: Acyclovir'),
nl,
write('Please do have oatmeal bath and stay at home because'),
nl.


hypothesis(measles) :-
symptom(fever),
symptom(runny_nose),
symptom(rash),
symptom(conjunctivitis),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Tylenol'),
nl,
write('2: Aleve'),
nl,
write('3: Advil'),
nl,
write('4: Vitamin A'),
nl,
write('Please get rest and use more liquid because'),
nl,!.


hypothesis(malaria) :-
symptom(fever),
symptom(sweating),
symptom(headache),
symptom(nausea),
symptom(vomiting),
symptom(diarrhea),
nl,
write('Advices and Sugestions:'),
nl,
write('1: Aralen'),
nl,
write('2: Qualaquin'),
nl,
write('3: Plaquenil'),
nl,
write('4: Mefloquine'),
nl,
write('Please do not sleep in open air and cover your full skin because'),
nl,!.


ask(Question) :-
write('Does the patient has the symptom '),
write(Question),
write('? : '),
read(Response),
nl,
( (Response == yes ; Response == y)
->
assert(yes(Question)) ;
assert(no(Question)), fail).
:- dynamic yes/1,no/1.

symptom(S) :-
(yes(S)
->
true ;
(no(S)
->
fail ;
ask(S))).

undo :- retract(yes(_)),fail.
undo :- retract(no(_)),fail.
undo.


/*
Output-
vnd@vnd-Lenovo-H520e:~$ swipl -s medicalExpert.pl
Welcome to SWI-Prolog (threaded, 64 bits, version 8.0.2)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.

For online help and background, visit http://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).

?- go.
Does the patient has the symptom headache? : y.

Does the patient has the symptom runny_nose? : |: n.

Does the patient has the symptom sore_throat? : |: y.

Does the patient has the symptom fever? : |: y.

Does the patient has the symptom chills? : |: y.

Does the patient has the symptom body_ache? : |: y.


Advices and Sugestions:
1: Tamiflu
2: Panadol
3: Zanamivir
Please take a warm bath and do salt gargling because
It is suggested that the patient has influenza
true .

?- 
*/

# ass 6 done

# information security 


Assignment 1
CODE
# Python code to demonstrate naive
# method to compute gcd ( recursion )

def hcf(a, b):
    if(b == 0):
        return a
    else:
        return hcf(b, a % b)

# prints 12
a=int(input("enter the first number "))
b=int(input("enter the second number "))
print("The gcd is : ", end="")
print(hcf(a, b))

OUTPUT
PS F:\SELF\BlockChain> python -u "f:\SELF\BlockChain\AI\IS_1.py"
enter the first number 50
enter the second number 60
The gcd is : 10
 
Assignment 2
CODE 
import java.io.*;
public class IS_2 {
    // int key[]= {0,0,1,0,0,1,0,1,1,1};
    int key[] = {
        1, 0, 1, 0, 0, 0, 0, 0, 1, 0
    }; // extra example for checking purpose
    int P10[] = { 3, 5, 2, 7, 4, 10, 1, 9, 8, 6 };
    int P8[] = { 6, 3, 7, 4, 8, 5, 10, 9 };
    int key1[] = new int[8];
    int key2[] = new int[8];
    int[] IP = { 2, 6, 3, 1, 4, 8, 5, 7 };
    int[] EP = { 4, 1, 2, 3, 2, 3, 4, 1 };
    int[] P4 = { 2, 4, 3, 1 };
    int[] IP_inv = { 4, 1, 3, 5, 7, 2, 8, 6 };
    int[][] S0 = { { 1, 0, 3, 2 },
                { 3, 2, 1, 0 },
                { 0, 2, 1, 3 },
                { 3, 1, 3, 2 } };
    int[][] S1 = { { 0, 1, 2, 3 },
                { 2, 0, 1, 3 },
                { 3, 0, 1, 0 },
                { 2, 1, 0, 3 } };
    // this function basically generates the key(key1 and
    //key2)  using P10 and P8 with (1 and 2)left shifts
    void key_generation()
    {
        int key_[] = new int[10];
        for (int i = 0; i < 10; i++) {
            key_[i] = key[P10[i] - 1];
        }
        int Ls[] = new int[5];
        int Rs[] = new int[5];
        for (int i = 0; i < 5; i++) {
            Ls[i] = key_[i];
            Rs[i] = key_[i + 5];
        }
        int[] Ls_1 = shift(Ls, 1);
        int[] Rs_1 = shift(Rs, 1);
        for (int i = 0; i < 5; i++) {
            key_[i] = Ls_1[i];
            key_[i + 5] = Rs_1[i];
        }
        for (int i = 0; i < 8; i++) {
            key1[i] = key_[P8[i] - 1];
        }
        int[] Ls_2 = shift(Ls, 2);
        int[] Rs_2 = shift(Rs, 2);
        for (int i = 0; i < 5; i++) {
            key_[i] = Ls_2[i];
            key_[i + 5] = Rs_2[i];
        }
        for (int i = 0; i < 8; i++) {
            key2[i] = key_[P8[i] - 1];
        }
        System.out.println("Your Key-1 :");
        for (int i = 0; i < 8; i++)
            System.out.print(key1[i] + " ");

        System.out.println();
        System.out.println("Your Key-2 :");
        for (int i = 0; i < 8; i++)
            System.out.print(key2[i] + " ");
    }    int[] shift(int[] ar, int n)
    {        while (n > 0) {
            int temp = ar[0];
            for (int i = 0; i < ar.length - 1; i++) {
                ar[i] = ar[i + 1];      }
            ar[ar.length - 1] = temp;
            n--;}
        return ar;}
    int[] encryption(int[] plaintext)
    { [] arr = new int[8];
        for (int i = 0; i < 8; i++) {
            arr[i] = plaintext[IP[i] - 1];  }
        int[] arr1 = function_(arr, key1);
        int[] after_swap = swap(arr1, arr1.length / 2);
        int[] arr2 = function_(after_swap, key2);
        int[] ciphertext = new int[8];
        for (int i = 0; i < 8; i++) {
            ciphertext[i] = arr2[IP_inv[i] - 1];}
        return ciphertext;}
String binary_(int val)
    {        if (val == 0)
            return "00";
        else if (val == 1)
            return "01";
        else if (val == 2)
            return "10";
        else
            return "11";
    }
    int[] function_(int[] ar, int[] key_)
    {
        int[] l = new int[4];
        int[] r = new int[4];
        for (int i = 0; i < 4; i++) {
            l[i] = ar[i];
            r[i] = ar[i + 4];
        }
        int[] ep = new int[8];
        for (int i = 0; i < 8; i++) {
            ep[i] = r[EP[i] - 1];
        }
        for (int i = 0; i < 8; i++) {
            ar[i] = key_[i] ^ ep[i];
        }
        int[] l_1 = new int[4];
        int[] r_1 = new int[4];

        for (int i = 0; i < 4; i++) {
            l_1[i] = ar[i];
            r_1[i] = ar[i + 4];
        }
        int row, col, val;
        row = Integer.parseInt("" + l_1[0] + l_1[3], 2);
        col = Integer.parseInt("" + l_1[1] + l_1[2], 2);
        val = S0[row][col];
        String str_l = binary_(val);
        row = Integer.parseInt("" + r_1[0] + r_1[3], 2);
        col = Integer.parseInt("" + r_1[1] + r_1[2], 2);
        val = S1[row][col];
        String str_r = binary_(val);
        int[] r_ = new int[4];
        for (int i = 0; i < 2; i++) {
            char c1 = str_l.charAt(i);
            char c2 = str_r.charAt(i);
            r_[i] = Character.getNumericValue(c1);
            r_[i + 2] = Character.getNumericValue(c2);
        }
        int[] r_p4 = new int[4];
        for (int i = 0; i < 4; i++) {
            r_p4[i] = r_[P4[i] - 1];
        }
        for (int i = 0; i < 4; i++) {
            l[i] = l[i] ^ r_p4[i];
        }
        int[] output = new int[8];
        for (int i = 0; i < 4; i++) {
            output[i] = l[i];
            output[i + 4] = r[i];
        }
        return output;
    }
    int[] swap(int[] array, int n)
    {
        int[] l = new int[n];
        int[] r = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = array[i];
            r[i] = array[i + n];
        }
        int[] output = new int[2 * n];
        for (int i = 0; i < n; i++) {
            output[i] = r[i];
            output[i + n] = l[i];
        }
        return output;
    }
    int[] decryption(int[] ar)
    {
        int[] arr = new int[8];
        for (int i = 0; i < 8; i++) {
            arr[i] = ar[IP[i] - 1];
        }
        int[] arr1 = function_(arr, key2);
        int[] after_swap = swap(arr1, arr1.length / 2);
        int[] arr2 = function_(after_swap, key1);
        int[] decrypted = new int[8];
        for (int i = 0; i < 8; i++) {
            decrypted[i] = arr2[IP_inv[i] - 1];
        }
        return decrypted;
    }
    public static void main(String[] args)
    {
        IS_2 obj = new IS_2();
        obj.key_generation(); 
        int[] plaintext = {
            1, 0, 0, 1, 0, 1, 1, 1
        }; 
        System.out.println();
        System.out.println("Your plain Text is :");
        for (int i = 0; i < 8; i++) 
            System.out.print(plaintext[i] + " ");

        int[] ciphertext = obj.encryption(plaintext);
        System.out.println();
        System.out.println(
            "Your cipher Text is :"); // printing the cipher
                                    // text
        for (int i = 0; i < 8; i++)
            System.out.print(ciphertext[i] + " ");
        int[] decrypted = obj.decryption(ciphertext);
        System.out.println();
        System.out.println(
            "Your decrypted Text is :"); // printing the
                                        // decrypted text
        for (int i = 0; i < 8; i++)
            System.out.print(decrypted[i] + " ");
    }
}
OUTPUT
PS F:\SELF\BlockChain\AI> cd "f:\SELF\BlockChain\AI\" ; if ($?) { javac IS_2.java } ; if ($?) { java IS_2 }
Your Key-1 :
1 0 1 0 0 1 0 0
Your Key-2 :
0 1 0 0 0 0 1 1
Your plain Text is :
1 0 0 1 0 1 1 1
Your cipher Text is :
0 0 1 1 1 0 0 0
Your decrypted Text is :
1 0 0 1 0 1 1 1
 
ASSIGNMENT 3
CODE
from math import sqrt
def prime(pr):
    for i in range(2, int(sqrt(pr))):
        if pr%i == 0:
            return False
    return True

def gcd(x, y):
    while(y):
        x, y = y, x % y 
    return x

import sys
def calc_key(phi):
    t = phi+1
    for i in range(2, phi):
        if prime(i) and t%i == 0:
            e = i
            d = int(t/e)
            return e, d
        if i == phi-1:
            sys.exit("Can't compute keys for existing prime nos.")

p = 11
q = 17
n = p*q
phi = (p-1)*(q-1)
e, d = calc_key(phi)
msg = 88
encrypt_msg = pow(msg, e, n)
decrypt_msg = pow(encrypt_msg, d, n)

print("Original Message: ", msg)
print("Encryption Key: ", e)
print("Decryption Key: ", d)
print("Encrypted Message: ", encrypt_msg)
print("Decrypted Message: ", decrypt_msg)

OUTPUT
PS F:\SELF\BlockChain\AI> python -u "f:\SELF\BlockChain\AI\IS_3.py"
Original Message:  88
Encryption Key:  7
Decryption Key:  23
Encrypted Message:  11
Decrypted Message:  88
 
ASSIGNMENT 4
CODE
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
public class IS_4 {
    public static String encryptThisString(String input)
    {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] messageDigest = md.digest(input.getBytes());
            BigInteger no = new BigInteger(1, messageDigest);

            String hashtext = no.toString(16);

            while (hashtext.length() < 32) {
                hashtext = "0" + hashtext;
            }
            return hashtext;
        }
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    public static void main(String args[]) throws
                                    NoSuchAlgorithmException
    {
        System.out.println("HashCode Generated by SHA-1 for: ");
        String s1 = "USER";
        System.out.println("\n" + s1 + " : " + encryptThisString(s1));
        String s2 = "Sinhgad Institutes";
        System.out.println("\n" + s2 + " : " + encryptThisString(s2));
    }
}
OUTPUT
PS F:\SELF\BlockChain\AI> cd "f:\SELF\BlockChain\AI\" ; if ($?) { javac IS_4.java } ; if ($?) { java IS_4 }
HashCode Generated by SHA-1 for: 

USER : 41f19702a400d516653ebee1618662b5aea8aa59

Sinhgad Institutes : 7c31c80b1f8740c76db5d8abef301f35a05424c5




